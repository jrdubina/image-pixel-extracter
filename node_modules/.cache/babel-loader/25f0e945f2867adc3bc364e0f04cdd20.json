{"ast":null,"code":"import { Children, Component } from 'react';\nimport Vibrant from 'node-vibrant';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}; // This component takes a src prop (image source, can be a blob or an image path) or intercepts it's children to get the image element,\n// and parses the image using node-vibrant, and finally invokes the prop callback with an array of colors.\n\n\nvar ColorExtractor = function (_React$Component) {\n  inherits(ColorExtractor, _React$Component);\n\n  function ColorExtractor() {\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ColorExtractor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.processImage = function () {\n      if (_this.props.children) {\n        // If the image element is direct children of ColorExtractor component, intercept the children and use the `src` property\n        // $FlowFixMe\n        if (_this.props.children.props.src) {\n          _this.parseImage(_this.props.children.props.src, _this.props);\n        }\n      } else if (_this.props.src && typeof _this.props.src === 'string' && _this.props.src.length > 0) {\n        // if the image is provided via src prop\n        _this.parseImage(_this.props.src, _this.props);\n      } else {\n        console.error(\"Please provide an image url using the 'src' prop or wrap an image element under the <ColorExtractor /> component. Check out the docs for more info - https://goo.gl/rMZ5L7\");\n      }\n    }, _this.parseImage = function (image, props) {\n      Vibrant.from(image).maxColorCount(props.maxColors).getSwatches().then(function (swatches) {\n        return props.getColors(_this.getColorsFromSwatches(swatches, props));\n      }).catch(function (error) {\n        if (error) {\n          // This error is mainly due to CORS issue. So we retry again by using the default image class. But if still there is any error, we bail out!\n          _this.useDefaultImageClass(image, props);\n        }\n      });\n    }, _this.useDefaultImageClass = function (image, props) {\n      // If there is any CORS issue, then the default class recreates the image element with crossOrigin set to anonymous.\n      new Vibrant.DefaultOpts.ImageClass() // $FlowFixMe\n      .load(image.src).then(function (data) {\n        if (data.image) {\n          Vibrant.from(data.image).getSwatches().then(function (swatches) {\n            return props.getColors(_this.getColorsFromSwatches(swatches, props));\n          }).catch(function (error) {\n            if (error) {\n              props.onError(error);\n            }\n          });\n        }\n      }).catch(function (error) {\n        if (error) {\n          props.onError(error);\n        }\n      });\n    }, _this.getColorsFromSwatches = function (swatches, props) {\n      var colors = [];\n\n      for (var swatch in swatches) {\n        if (swatches.hasOwnProperty(swatch) && swatches[swatch]) {\n          if (props.rgb) {\n            colors.push(swatches[swatch].getRgb());\n          } else {\n            colors.push(swatches[swatch].getHex());\n          }\n        }\n      }\n\n      return colors;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  ColorExtractor.prototype.componentDidMount = function componentDidMount() {\n    this.processImage();\n  }; // If the src url is being passed by the parent component, and if it updates later then we need\n  // to parse the updated image again!\n\n\n  ColorExtractor.prototype.componentDidUpdate = function componentDidUpdate(props) {\n    // Check whether the src image or image element is new. If it's a new url, parse the image again!\n    if (props.src !== this.props.src && typeof this.props.src === 'string' && this.props.src.length > 0) {\n      this.parseImage(this.props.src, this.props);\n    } else if (this.props.children && // $FlowFixMe\n    props.children.props.src !== this.props.children.props.src) {\n      // $FlowFixMe\n      this.parseImage(this.props.children.props.src, this.props);\n    }\n  }; // Parse the image and extract the colors\n  // Get the array of colors from swatches\n\n\n  ColorExtractor.prototype.render = function render() {\n    var length = Children.count(this.props.children); // We don't handle multiple images at the moment or custom components, sorry!\n\n    if (length > 1) {\n      throw new Error('Expected only one image element.');\n    } else if (length === 1) {\n      // Children should be an image element\n      // $FlowFixMe\n      if (this.props.children.type === 'img') {\n        return this.props.children;\n      } else {\n        throw new Error('Expected children to be an image element but instead got a \"' + this.props.children.type + '\"');\n      }\n    } else {\n      return null;\n    }\n  };\n\n  return ColorExtractor;\n}(Component);\n\nColorExtractor.defaultProps = {\n  onError: function onError(error) {},\n  // Colors can be in vec3 format (rgb or hsl) or in hex format\n  getColors: function getColors(colors) {},\n  rgb: false,\n  hex: true,\n  src: null,\n  maxColors: 64\n};\nexport { ColorExtractor };","map":null,"metadata":{},"sourceType":"module"}